Benchmark Marching Cubes
Ejecutable: ./marching1_omp
================================

>>> Resolucion = 0.02
Hilos: 1 -> 2.33791
Hilos: 2 -> 1.18353
Hilos: 4 -> 0.618071
Hilos: 8 -> 0.448673
Hilos: 12 -> 0.451578

>>> Resolucion = 0.01
Hilos: 1 -> 2.35733
Hilos: 2 -> 1.15361
Hilos: 4 -> 0.642317
Hilos: 8 -> 0.480007
Hilos: 12 -> 0.428138

>>> Resolucion = 0.005
Hilos: 1 -> 2.33087
Hilos: 2 -> 1.16749
Hilos: 4 -> 0.649881
Hilos: 8 -> 0.406843
Hilos: 12 -> 0.383585


(strong scaling).
############################################
Eso se llama escalamiento fuerte (strong scaling).
n fijo → resolución 0.01
p creciente → 1, 2, 4, 8, 16, 32, 40, 64, 80
Obj: ver qué tanto baja el tiempo cuando agregas más hilos.
[iran.alvarez@khipu code]$ nano bench_khipu.slurm
[iran.alvarez@khipu code]$ sbatch bench_khipu.slurm
Submitted batch job 17773
[iran.alvarez@khipu code]$ squeue --me
             JOBID PARTITION     NAME     USER ST       TIME  NODES NODELIST(REASON)
             17773  standard mc_bench iran.alv  R       0:07      1 n003
[iran.alvarez@khipu code]$ squeue --me
             JOBID PARTITION     NAME     USER ST       TIME  NODES NODELIST(REASON)
[iran.alvarez@khipu code]$ cat bench.out
Nodo asignado:
n003
CPUs asignadas: 32

CPU info:
CPU(s):              32
On-line CPU(s) list: 0-31
NUMA node0 CPU(s):   0-15
NUMA node1 CPU(s):   16-31
============== Ejecutable: marching1_omp ==============
Hilos: 1  -> 0.910239
Hilos: 2  -> 0.520692
Hilos: 4  -> 0.258712
Hilos: 8  -> 0.143153
Hilos: 16  -> 0.0863158
Hilos: 32  -> 0.0609951
Hilos: 40  -> 0.0766211
Hilos: 64  -> 0.0660547
Hilos: 80  -> 0.0718586

============== Ejecutable: marching2_omp ==============
Hilos: 1  -> 0.940329
Hilos: 2  -> 0.505408
Hilos: 4  -> 0.264213
Hilos: 8  -> 0.142202
Hilos: 16  -> 0.0882674
Hilos: 32  -> 0.062224
Hilos: 40  -> 0.0767436
Hilos: 64  -> 0.0726943
Hilos: 80  -> 0.0698061

============== Ejecutable: marching3_omp ==============
Hilos: 1  -> 1.01589
Hilos: 2  -> 0.519248
Hilos: 4  -> 0.258192
Hilos: 8  -> 0.145226
Hilos: 16  -> 0.0890452
Hilos: 32  -> 0.0673357
Hilos: 40  -> 0.0860668
Hilos: 64  -> 0.0936081
Hilos: 80  -> 0.0890744

[iran.alvarez@khipu code]$ cat bench.err
[iran.alvarez@khipu code]$ 


NUMA importa
El cuello real de Marching Cubes es memoria, no CPU
OpenMP escala muy bien hasta ~32 cores en tareas geométricas densas
Más threads ≠ más rendimiento pasado un punto

(weak scaling).
#############################################3
[iran.alvarez@khipu code]$ sbatch bench_weak.slurm
Submitted batch job 17775
[iran.alvarez@khipu code]$ cat weak.out
Weak Scaling Benchmark
Nodo: n003
CPUs asignadas: 32

============== Ejecutable: marching1_omp ==============
Hilos: 1, step: 0.02 -> 0.126339
Hilos: 2, step: 0.016 -> 0.119285
Hilos: 4, step: 0.0127 -> 0.123025
Hilos: 8, step: 0.01 -> 0.13908
Hilos: 16, step: 0.0079 -> 0.155675
Hilos: 32, step: 0.0063 -> 0.199401

============== Ejecutable: marching2_omp ==============
Hilos: 1, step: 0.02 -> 0.123775
Hilos: 2, step: 0.016 -> 0.125709
Hilos: 4, step: 0.0127 -> 0.127542
Hilos: 8, step: 0.01 -> 0.144999
Hilos: 16, step: 0.0079 -> [iran.alvarez@khipu code]$
[iran.alvarez@khipu code]$ g++ compartido3.cpp -fopenmp -O3 -o marching3_omp
[iran.alvarez@khipu code]$ cat weak.out
Weak Scaling Benchmark
Nodo: n003
CPUs asignadas: 32

============== Ejecutable: marching1_omp ==============
Hilos: 1, step: 0.02 -> 0.126339
Hilos: 2, step: 0.016 -> 0.119285
Hilos: 4, step: 0.0127 -> 0.123025
Hilos: 8, step: 0.01 -> 0.13908
Hilos: 16, step: 0.0079 -> 0.155675
Hilos: 32, step: 0.0063 -> 0.199401

============== Ejecutable: marching2_omp ==============
Hilos: 1, step: 0.02 -> 0.123775
Hilos: 2, step: 0.016 -> 0.125709
Hilos: 4, step: 0.0127 -> 0.127542
Hilos: 8, step: 0.01 -> 0.144999
Hilos: 16, step: 0.0079 -> 0.170197
Hilos: 32, step: 0.0063 -> 0.204886

============== Ejecutable: marching3_omp ==============
Hilos: 1, step: 0.02 -> 0.121919
Hilos: 2, step: 0.016 -> 0.12771
Hilos: 4, step: 0.0127 -> 0.130708
Hilos: 8, step: 0.01 -> 0.147172
Hilos: 16, step: 0.0079 -> 0.170174
Hilos: 32, step: 0.0063 -> 0.222556

[iran.alvarez@khipu code]$ 


##########################################333
weak scale main (test2)

int main(int argc, char** argv) {
    double step = 0.01; // valor por defecto
    if (argc > 1) {
        step = atof(argv[1]);
    }

    auto f = [](double x, double y, double z) {
        double cx=0.5, cy=0.5, cz=0.5, r=0.5;
        return (x-cx)*(x-cx)+(y-cy)*(y-cy)+(z-cz)*(z-cz)-r*r;
    };

    draw_curve(f, "out.ply", -1, -1, -1, 2, 2, 2, step);
    return 0;
}

##########################################333
strong scale main (test1)

int main(int argc, char** argv) {
    double step = 0.01;
    if (argc > 1) step = atof(argv[1]);

    auto f = [](double x, double y, double z) {
        double cx=0.5, cy=0.5, cz=0.5, r=0.5;
        return (x-cx)*(x-cx)+(y-cy)*(y-cy)+(z-cz)*(z-cz)-r*r;
    };

    draw_curve(f, "out.ply", -1,-1,-1, 2,2,2, step);
    return 0;
}


