############################################
# HPC Benchmarks: Marching Cubes + OpenMP
# Plataforma: Cluster Khipu (32–80 cores)
# Trabajo: Strong y Weak Scaling
# Algoritmos:
#   marching1_omp -> merge con critical (una vez por hilo)
#   marching2_omp -> buffers privados por thread id (tid)
#   marching3_omp -> reserve() local sin optimización de merge
############################################


============================================
STRONG SCALING (Problema fijo)
============================================
# Tamaño del problema constante
# Resolver más rápido al aumentar número de hilos
# Command pattern:
#   OMP_NUM_THREADS=p ./marchingX_omp

# Strong scaling local (máximo 12 hilos)

>>> Resolucion = 0.02
Hilos: 1  -> 2.33791
Hilos: 2  -> 1.18353
Hilos: 4  -> 0.618071
Hilos: 8  -> 0.448673
Hilos: 12 -> 0.451578

>>> Resolucion = 0.01
Hilos: 1  -> 2.35733
Hilos: 2  -> 1.15361
Hilos: 4  -> 0.642317
Hilos: 8  -> 0.480007
Hilos: 12 -> 0.428138

>>> Resolucion = 0.005
Hilos: 1  -> 2.33087
Hilos: 2  -> 1.16749
Hilos: 4  -> 0.649881
Hilos: 8  -> 0.406843
Hilos: 12 -> 0.383585

# Strong scaling en el cluster Khipu (32–80 hilos)

============== marching1_omp ==============
1  -> 0.910239
2  -> 0.520692
4  -> 0.258712
8  -> 0.143153
16 -> 0.0863158
32 -> 0.0609951
40 -> 0.0766211
64 -> 0.0660547
80 -> 0.0718586

============== marching2_omp ==============
1  -> 0.940329
2  -> 0.505408
4  -> 0.264213
8  -> 0.142202
16 -> 0.0882674
32 -> 0.062224
40 -> 0.0767436
64 -> 0.0726943
80 -> 0.0698061

============== marching3_omp ==============
1  -> 1.01589
2  -> 0.519248
4  -> 0.258192
8  -> 0.145226
16 -> 0.0890452
32 -> 0.0673357
40 -> 0.0860668
64 -> 0.0936081
80 -> 0.0890744

# Conclusiones Strong Scaling
# - Escalamiento casi lineal hasta casi 16 hilos
# - Buen rendimiento hasta casi 32 hilos
# - Luego saturación por ancho de banda de memoria
# - marching2_omp mejor estabilidad
# - Nota: más hilos != más rendimiento (NUMA / memory bound)


============================================
WEAK SCALING (Problema crece con núm. hilos)
============================================
# Tamaño del problema proporcional a los hilos
# Objetivo: tiempo estable al aumentar p
# step ↓ cuando p ↑

============== marching1_omp ==============
1  (0.02)   -> 0.126339
2  (0.016)  -> 0.119285
4  (0.0127) -> 0.123025
8  (0.01)   -> 0.13908
16 (0.0079) -> 0.155675
32 (0.0063) -> 0.199401

============== marching2_omp ==============
1  -> 0.123775
2  -> 0.125709
4  -> 0.127542
8  -> 0.144999
16 -> 0.170197
32 -> 0.204886

============== marching3_omp ==============
1  -> 0.121919
2  -> 0.12771
4  -> 0.130708
8  -> 0.147172
16 -> 0.170174
32 -> 0.222556

# Conclusiones Weak Scaling
# - Tiempo aumenta lentamente (comportamiento esperado)
# - Buena eficiencia hasta 32 hilos
# - marching1_omp y marching2_omp mejor respuesta
# - marching3_omp menor eficiencia


============================================
INTERPRETACIÓN GLOBAL
============================================
# Hallazgos clave
# - Marching Cubes es memory-bound, no compute-bound
# - OpenMP escala muy bien hasta 16–32 cores
# - NUMA afecta más allá de 32 hilos
# - Mejor diseño: buffers por hilo (marching2_omp)
# - critical por hilo tiene buen rendimiento (bajo overhead)
# - reserve solo no mejora escalamiento

# Conclusión HPC
# El código presenta escalamiento fuerte y débil sólido,
# con limitantes esperadas por arquitectura NUMA y
# ancho de banda de memoria.

============================================
MAIN para strong / weak scaling
============================================

# Weak scaling main
int main(int argc, char** argv) {
    double step = 0.01;
    if (argc > 1) step = atof(argv[1]);
    auto f = [](double x,double y,double z){
        double cx=0.5,cy=0.5,cz=0.5,r=0.5;
        return (x-cx)*(x-cx)+(y-cy)*(y-cy)+(z-cz)*(z-cz)-r*r;
    };
    draw_curve(f,"out.ply",-1,-1,-1,2,2,2,step);
}

# Strong scaling main
int main(int argc, char** argv) {
    double step = 0.01;
    if (argc > 1) step = atof(argv[1]);
    auto f = [](double x,double y,double z){
        double cx=0.5,cy=0.5,cz=0.5,r=0.5;
        return (x-cx)*(x-cx)+(y-cy)*(y-cy)+(z-cz)*(z-cz)-r*r;
    };
    draw_curve(f,"out.ply",-1,-1,-1,2,2,2,step);
}
